{"ast":null,"code":"import { Layer, Network } from 'synaptic';\n\nclass NNetwork {\n  constructor() {\n    this.learningRate = 0.3;\n    var inputLayer = new Layer(1);\n    var hiddenLayer = new Layer(5);\n    var outputLayer = new Layer(1);\n    inputLayer.project(hiddenLayer);\n    hiddenLayer.project(outputLayer);\n    this.nn = new Network({\n      input: inputLayer,\n      hidden: [hiddenLayer],\n      output: outputLayer\n    });\n    /*for(var i=0;i<10;i++){\n      this.nn.activate([Math.random()]);\n      this.nn.propagate(this.learningRate,\n        [Math.random(),Math.random(),Math.random(),Math.random()]);\n    }*/\n  }\n\n}\n\nconst WIDTH = 640;\nconst HEIGHT = 480;\n\nconst getRadian = angle => angle * Math.PI / 180;\n\nclass DistanceSensor {\n  constructor() {\n    this.maxDistance = 100;\n    this.foundX = 0;\n    this.foundY = 0;\n\n    this.findIntersection = (worldPixels, targetX, targetY, carX, carY, carAngle) => {\n      const distance = Math.sqrt(Math.pow(carX - targetX, 2) + Math.pow(carY - targetY, 2));\n\n      if (distance > this.maxDistance) {\n        return false;\n      }\n\n      const pixel = worldPixels[Math.floor(carY) * WIDTH + Math.floor(carX)];\n\n      if (pixel && pixel[0] !== 0) {\n        const centerX = carX + (targetX - carX) / 2;\n        const centerY = carY + (targetY - carY) / 2;\n        return this.findIntersection(worldPixels, carX + 1 * Math.cos(getRadian(carAngle)), carY + 1 * Math.sin(getRadian(carAngle)), centerX, centerY, carAngle);\n      }\n\n      return [carX, carY];\n    };\n\n    this.getValue = (worldPixels, carX, carY, carAngle) => {\n      const targetX = carX + this.maxDistance * Math.cos(getRadian(carAngle));\n      const targetY = carY + this.maxDistance * Math.sin(getRadian(carAngle));\n\n      if (worldPixels) {\n        const result = this.findIntersection(worldPixels, carX, carY, targetX, targetY, carAngle);\n        const [foundX, foundY] = result ? result : [targetX, targetY];\n        this.foundX = foundX;\n        this.foundY = foundY;\n        return Math.min(1, Math.sqrt(Math.pow(carX - foundX, 2) + Math.pow(carY - foundY, 2)) / this.maxDistance);\n      }\n\n      return 0;\n    };\n  }\n\n}\n\nclass Car {\n  constructor() {\n    this.speedUp = () => {\n      this.speed = Math.min(this.maxSpeed, this.speed += this.acceleration);\n    };\n\n    this.speedDown = () => {\n      this.speed = Math.max(0, this.speed -= this.acceleration);\n    };\n\n    this.steerLeft = () => {\n      this.angle = (this.angle - 1) % 360;\n    };\n\n    this.steerRight = () => {\n      this.angle = (this.angle + 1) % 360;\n    };\n\n    this.update = (myNetwork, worldPixels) => {\n      this.x += this.speed * Math.cos(getRadian(this.angle));\n      this.y += this.speed * Math.sin(getRadian(this.angle));\n      const sensorData = this.collectSensorData(worldPixels);\n      console.log(sensorData[0]);\n\n      if (sensorData[0] === 0) {\n        console.log('dead');\n        this.reset(); //myNetwork.nn.propagate(0.3,[((Date.now() - this.start)/1000)/20]);\n      } else {//myNetwork.nn.propagate(0.0000005,[1]);\n        }\n\n      const [command] = myNetwork.nn.activate([sensorData]); //console.log(command, sensorData[0]);\n\n      if (Math.random() < 0.7) {\n        if (command < 0.5) {\n          this.steerLeft();\n        } else {\n          this.steerRight();\n        }\n      }\n\n      const newSensorData = this.collectSensorData(worldPixels);\n\n      if (newSensorData[0] < sensorData[0]) {\n        myNetwork.nn.propagate(0.3, [1 - command]);\n      } //  myNetwork.propagate(learningRate, [0]);\n\n    };\n\n    this.collectSensorData = worldPixels => {\n      return this.sensors.map(sensor => sensor.getValue(worldPixels, this.x, this.y, this.angle));\n    };\n\n    this.reset();\n  }\n\n  reset() {\n    this.start = Date.now();\n    this.x = 50;\n    this.y = 50;\n    this.height = 25;\n    this.width = 40;\n    this.speed = 0;\n    this.sensors = [new DistanceSensor()];\n    this.maxSpeed = 2;\n    this.acceleration = 0.5;\n    this.angle = 0;\n  }\n\n}\n\n;\nexport default function sketch(p) {\n  let worldPixels;\n  let canvas;\n  let image;\n  const car = new Car();\n  const myNetwork = new NNetwork();\n\n  p.setup = () => {\n    image = p.createImage(WIDTH, HEIGHT);\n    canvas = p.createCanvas(WIDTH, HEIGHT);\n    p.noStroke();\n    p.background(0);\n    worldPixels = JSON.parse(window.localStorage.getItem('map'));\n    const image1 = p.get(0, 0, WIDTH, HEIGHT);\n    image1.loadPixels();\n\n    for (var i = 0; i < image1.pixels.length; i += 4) {\n      const startIndex = Math.floor(i / 4);\n      image1.pixels[i] = worldPixels[startIndex][0];\n      image1.pixels[i + 1] = worldPixels[startIndex][1];\n      image1.pixels[i + 2] = worldPixels[startIndex][2];\n    }\n\n    image1.updatePixels();\n    image = image1;\n  };\n\n  p.mousePressed = () => {};\n\n  p.draw = () => {\n    p.background(255);\n    p.update();\n\n    if (image) {\n      p.image(image, 0, 0, WIDTH, HEIGHT);\n    }\n\n    p.translate(car.x + car.width / 2, car.y + car.height / 2);\n    p.angleMode(p.DEGREES);\n    p.rotate(car.angle);\n    p.fill(150, 100, 200);\n    const carRelativeCenterX = 0 - car.width / 2;\n    const carRelativeCenterY = 0 - car.height / 2;\n    p.rect(carRelativeCenterX, carRelativeCenterY, car.width, car.height);\n    p.fill(150, 150, 150);\n    p.rect(carRelativeCenterX + 20, carRelativeCenterY + 5, 10, 15);\n    p.fill('black');\n    p.rect(carRelativeCenterX + 36, carRelativeCenterY + 0, 4, 6);\n    p.rect(carRelativeCenterX + 36, carRelativeCenterY + 19, 4, 6);\n    p.stroke('red');\n    car.sensors.map(sensor => {\n      const targetX = sensor.maxDistance * Math.cos(getRadian(car.angle));\n      const targetY = sensor.maxDistance * Math.sin(getRadian(car.angle));\n      p.rotate(-car.angle);\n      p.line(0, 0, targetX, targetY);\n      p.translate(0, 0);\n      p.rect(sensor.foundX, sensor.foundY, 15, 15);\n    });\n    p.stroke(1);\n  };\n\n  p.update = () => {\n    if (p.keyIsDown(87)) {\n      car.speedUp();\n    }\n\n    if (p.keyIsDown(83)) {\n      car.speedDown();\n    }\n\n    if (p.keyIsDown(65)) {\n      car.steerLeft();\n    }\n\n    if (p.keyIsDown(68)) {\n      car.steerRight();\n    }\n\n    car.update(myNetwork, worldPixels);\n  };\n\n  p.myCustomRedrawAccordingToNewPropsHandler = newProps => {\n    if (canvas) p.fill(newProps.color);\n  };\n\n  p.keyPressed = () => {\n    if (p.keyCode == 76) {}\n  };\n}","map":{"version":3,"sources":["/home/caner/Desktop/selfcar/src/components/game-sketch.js"],"names":["Layer","Network","NNetwork","constructor","learningRate","inputLayer","hiddenLayer","outputLayer","project","nn","input","hidden","output","WIDTH","HEIGHT","getRadian","angle","Math","PI","DistanceSensor","maxDistance","foundX","foundY","findIntersection","worldPixels","targetX","targetY","carX","carY","carAngle","distance","sqrt","pow","pixel","floor","centerX","centerY","cos","sin","getValue","result","min","Car","speedUp","speed","maxSpeed","acceleration","speedDown","max","steerLeft","steerRight","update","myNetwork","x","y","sensorData","collectSensorData","console","log","reset","command","activate","random","newSensorData","propagate","sensors","map","sensor","start","Date","now","height","width","sketch","p","canvas","image","car","setup","createImage","createCanvas","noStroke","background","JSON","parse","window","localStorage","getItem","image1","get","loadPixels","i","pixels","length","startIndex","updatePixels","mousePressed","draw","translate","angleMode","DEGREES","rotate","fill","carRelativeCenterX","carRelativeCenterY","rect","stroke","line","keyIsDown","myCustomRedrawAccordingToNewPropsHandler","newProps","color","keyPressed","keyCode"],"mappings":"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","sourcesContent":["import {Layer, Network} from 'synaptic';\nclass NNetwork{\n  learningRate = 0.3;\n  constructor(){\n    var inputLayer = new Layer(1);\n    var hiddenLayer = new Layer(5);\n    var outputLayer = new Layer(1);\n    inputLayer.project(hiddenLayer);\n    hiddenLayer.project(outputLayer);\n    this.nn = new Network({\n      input: inputLayer,\n    \thidden: [hiddenLayer],\n    \toutput: outputLayer\n    });\n    /*for(var i=0;i<10;i++){\n      this.nn.activate([Math.random()]);\n      this.nn.propagate(this.learningRate,\n        [Math.random(),Math.random(),Math.random(),Math.random()]);\n    }*/\n  }\n}\nconst WIDTH = 640;\nconst HEIGHT = 480;\nconst getRadian = angle => angle * Math.PI / 180;\nclass DistanceSensor{\n  maxDistance = 100;\n  foundX = 0;\n  foundY = 0;\n  findIntersection = (worldPixels, targetX, targetY, carX, carY, carAngle) => {\n    const distance = Math.sqrt(\n      Math.pow((carX - targetX), 2) +\n      Math.pow((carY - targetY), 2)\n    )\n    if(distance > this.maxDistance){\n      return false;\n    }\n    const pixel = worldPixels[Math.floor(carY) * WIDTH + Math.floor(carX)];\n    if(pixel && pixel[0] !== 0){\n      const centerX = carX + (targetX - carX) / 2;\n      const centerY = carY + (targetY - carY) / 2;\n      return this.findIntersection(worldPixels,\n        carX + 1 * Math.cos(getRadian(carAngle)),\n        carY + 1 * Math.sin(getRadian(carAngle)),\n        centerX,\n        centerY,\n        carAngle\n      );\n    }\n    return [carX, carY];\n  }\n  getValue = (worldPixels, carX, carY, carAngle) =>{\n    const targetX = carX + this.maxDistance * Math.cos(getRadian(carAngle));\n    const targetY = carY + this.maxDistance * Math.sin(getRadian(carAngle));\n    if(worldPixels){\n      const result = this.findIntersection(worldPixels, carX, carY, targetX, targetY, carAngle);\n      const [foundX, foundY] = result ? result : [targetX,targetY];\n      this.foundX = foundX;\n      this.foundY = foundY;\n      return Math.min(1,Math.sqrt(Math.pow((carX - foundX),2)+Math.pow((carY - foundY),2)) / this.maxDistance);\n    }\n    return 0;\n  };\n}\n\nclass Car{\n  constructor(){\n    this.reset();\n  }\n  reset(){\n    this.start = Date.now();\n    this.x = 50;\n    this.y = 50;\n    this.height = 25;\n    this.width = 40;\n    this.speed = 0;\n    this.sensors = [new DistanceSensor()];\n    this.maxSpeed = 2;\n    this.acceleration = 0.5;\n    this.angle = 0;\n  }\n  speedUp = () => {\n    this.speed = Math.min(this.maxSpeed, this.speed += this.acceleration);\n  };\n  speedDown = () => {\n    this.speed = Math.max(0, this.speed -= this.acceleration);\n  };\n  steerLeft = () => {\n    this.angle = (this.angle -1) % 360;\n  }\n  steerRight = () => {\n    this.angle = (this.angle +1) % 360;\n  }\n  update = (myNetwork,worldPixels) => {\n    this.x += this.speed * Math.cos(getRadian(this.angle));\n    this.y += this.speed * Math.sin(getRadian(this.angle));\n    const sensorData = this.collectSensorData(worldPixels);\n    console.log(sensorData[0]);\n    if(sensorData[0] === 0) {\n      console.log('dead');\n      this.reset();\n      //myNetwork.nn.propagate(0.3,[((Date.now() - this.start)/1000)/20]);\n    } else {\n      //myNetwork.nn.propagate(0.0000005,[1]);\n    }\n    const [command] = myNetwork.nn.activate([sensorData]);\n    //console.log(command, sensorData[0]);\n\n    if(Math.random()<0.7){\n    if(command<0.5){\n      this.steerLeft();\n    }\n    else{\n      this.steerRight();\n    }\n  }\n  const newSensorData = this.collectSensorData(worldPixels);\n  if (newSensorData[0] < sensorData[0]){\n    myNetwork.nn.propagate(0.3,[1-command])\n  }\n  //  myNetwork.propagate(learningRate, [0]);\n  };\n  collectSensorData = (worldPixels) => {\n    return this.sensors.map(sensor =>\n      sensor.getValue(worldPixels, this.x, this.y, this.angle));\n  }\n};\n\nexport default function sketch(p){\n  let worldPixels;\n  let canvas;\n  let image;\n  const car = new Car();\n  const myNetwork = new NNetwork();\n  p.setup = () => {\n    image = p.createImage(WIDTH, HEIGHT);\n    canvas = p.createCanvas(WIDTH, HEIGHT);\n    p.noStroke();\n    p.background(0);\n    worldPixels = JSON.parse(window.localStorage.getItem('map'));\n    const image1 = p.get(0, 0, WIDTH, HEIGHT);\n    image1.loadPixels();\n    for(var i = 0; i < image1.pixels.length; i += 4){\n      const startIndex = Math.floor(i/4);\n      image1.pixels[i] = worldPixels[startIndex][0];\n      image1.pixels[i+1] = worldPixels[startIndex][1];\n      image1.pixels[i+2] = worldPixels[startIndex][2];\n  }\n  image1.updatePixels();\n  image=image1;\n  }\n  p.mousePressed = () => {\n  }\n  p.draw = () => {\n    p.background(255);\n    p.update();\n    if (image){\n      p.image(image,0,0,WIDTH,HEIGHT);\n    }\n    p.translate(car.x + car.width/2, car.y + car.height/2);\n    p.angleMode(p.DEGREES);\n    p.rotate( car.angle);\n    p.fill(150,100,200);\n    const carRelativeCenterX = 0-car.width / 2;\n    const carRelativeCenterY = 0-car.height / 2;\n    p.rect(carRelativeCenterX,carRelativeCenterY, car.width, car.height);\n    p.fill(150,150,150);\n    p.rect(carRelativeCenterX + 20 ,carRelativeCenterY + 5,10,15);\n    p.fill('black');\n    p.rect(carRelativeCenterX + 36,carRelativeCenterY + 0,4,6);\n    p.rect(carRelativeCenterX + 36,carRelativeCenterY + 19,4,6);\n    p.stroke('red');\n    car.sensors.map(sensor => {\n      const targetX = sensor.maxDistance * Math.cos(getRadian(car.angle));\n      const targetY = sensor.maxDistance * Math.sin(getRadian(car.angle));\n      p.rotate(-car.angle);\n      p.line(0,0,targetX,targetY);\n      p.translate(0,0);\n      p.rect(sensor.foundX,sensor.foundY,15,15);\n    });\n    p.stroke(1);\n  }\n  p.update = () => {\n    if (p.keyIsDown(87)){\n      car.speedUp();\n    }\n    if (p.keyIsDown(83)){\n      car.speedDown();\n    }\n    if (p.keyIsDown(65)){\n      car.steerLeft();\n    }\n    if (p.keyIsDown(68)){\n      car.steerRight();\n    }\n    car.update(myNetwork,worldPixels);\n  };\n  p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n    if(canvas)\n      p.fill(newProps.color);\n  }\n  p.keyPressed = () => {\n    if(p.keyCode == 76){\n\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}