{"ast":null,"code":"import { Network, Layer } from 'synaptic';\n\nclass NNetwork {\n  constructor() {\n    this.learningRate = 0.3;\n    var inputLayer = new Layer(2);\n    var hiddenLayer1 = new Layer(10); // var hiddenLayer2 = new Layer(5);\n\n    var outputLayer = new Layer(2);\n    inputLayer.project(hiddenLayer1);\n    hiddenLayer1.project(outputLayer); // hiddenLayer2.project(outputLayer);\n\n    this.nn = new Network({\n      input: inputLayer,\n      hidden: [hiddenLayer1],\n      output: outputLayer\n    }); // console.log(this.nn)\n    // for (var i = 0; i < 10; i++) {\n    // \tthis.nn.activate([Math.random()]);\n    // \tthis.nn.propagate(\n    //     this.learningRate,\n    //     [Math.random(), Math.random(), Math.random(), Math.random()]\n    //   );\n    // }\n    // console.log('trained')\n    // console.log(this.nn.activate([Math.random()]));\n  }\n\n}\n\nconst WIDTH = 640;\nconst HEIGHT = 480;\n\nconst getRadian = angle => angle * Math.PI / 180;\n\nclass DistanceSensor {\n  constructor() {\n    this.maxDistance = 100;\n    this.foundX = 0;\n    this.foundY = 0;\n\n    this.findIntersection = (counter, worldPixels, carX, carY, targetX, targetY, carAngle) => {\n      const distance = Math.sqrt(Math.pow(carX - targetX, 2) + Math.pow(carY - targetY, 2)); // console.log(distance)\n\n      if (counter > this.maxDistance) {\n        return false;\n      }\n\n      const pixel = worldPixels[Math.floor(carY) * WIDTH + Math.floor(carX)];\n\n      if (pixel && pixel[0] !== 0) {\n        // const centerX = carX + (targetX - carX ) / 2\n        // const centerY = carY + (targetY - carY ) / 2\n        return this.findIntersection(counter + 1, worldPixels, carX + 1 * Math.cos(getRadian(carAngle)), carY + 1 * Math.sin(getRadian(carAngle)), targetX, targetY, carAngle);\n      }\n\n      return [carX, carY];\n    };\n\n    this.getValue = (worldPixels, carX, carY, carAngle) => {\n      const targetX = carX + this.maxDistance * Math.cos(getRadian(carAngle)) + 20;\n      const targetY = carY + this.maxDistance * Math.sin(getRadian(carAngle)) + 12.5;\n\n      if (worldPixels) {\n        const result = this.findIntersection(0, worldPixels, carX, carY, targetX, targetY, carAngle);\n        const [foundX, foundY] = result ? result : [targetX, targetY];\n        this.foundX = foundX;\n        this.foundY = foundY;\n        return Math.min(1, Math.sqrt(Math.pow(carX - foundX, 2) + Math.pow(carY - foundY, 2)) / this.maxDistance);\n      }\n\n      return 0;\n    };\n  }\n\n}\n\nlet carCounter = 0;\n\nclass Car {\n  constructor() {\n    this.speedUp = () => {// this.speed = Math.min(this.maxSpeed, this.speed += this.acc);\n    };\n\n    this.speedDown = () => {// this.speed = Math.max(0.1, this.speed -= this.acc);\n    };\n\n    this.steerLeft = () => {\n      this.angle = (this.angle - 4) % 360;\n    };\n\n    this.steerRight = () => {\n      this.angle = (this.angle + 4) % 360;\n    };\n\n    this.update = (myNetwork, worldPixels) => {\n      this.x += this.speed * Math.cos(getRadian(this.angle));\n      this.y += this.speed * Math.sin(getRadian(this.angle));\n      const sensorData = this.collectSensorData(worldPixels);\n\n      if (sensorData[0] === 0) {\n        console.log('dead');\n        this.reset(); // myNetwork.nn.propagate(0.3, [((Date.now() - this.start) / 1000) / 20]);\n      } else {} // myNetwork.nn.propagate(0.3, [1]);\n        // TODO angle?\n\n\n      let [output1, output2] = myNetwork.nn.activate([sensorData, this.angle]); // if (this.speed === 0.1) {\n      //   console.log(this.id);\n      //   myNetwork.nn.propagate(0.1, [\n      //     Math.random(),\n      //     0.6\n      //   ])\n      // }\n\n      const shouldSteerLeft = output1 > output2;\n\n      if (shouldSteerLeft) {\n        this.steerLeft();\n      } else {\n        this.steerRight();\n      } // if (speed <= 0.5) {\n      //   this.speedDown();\n      // } else if (speed > 0.5) {\n      //   this.speedUp();\n      // }\n\n\n      const newSensorData = this.collectSensorData(worldPixels);\n\n      if (newSensorData[0] === 1) {\n        myNetwork.nn.propagate(0.3, [0.5, 0.5]);\n      } else if (newSensorData[0] < sensorData[0]) {\n        myNetwork.nn.propagate(0.2, shouldSteerLeft ? [0, 1] : [1, 0]);\n      } else {// myNetwork.nn.propagate(0.2, [output1, output2])\n      }\n    };\n\n    this.collectSensorData = worldPixels => {\n      return this.sensors.map(sensor => sensor.getValue(worldPixels, this.x, this.y, this.angle));\n    };\n\n    this.reset();\n    this.id = carCounter++;\n  }\n\n  reset() {\n    this.start = Date.now();\n    this.x = 80;\n    this.y = 100;\n    this.width = 40;\n    this.height = 25;\n    this.angle = 0;\n    this.sensors = [new DistanceSensor()];\n    this.speed = 2;\n    this.maxSpeed = 3;\n    this.acc = 0.5;\n  }\n\n}\n\n;\nexport default function sketch(p) {\n  let frameCount = 0;\n  const cars = [];\n\n  for (var i = 0; i < 100; i++) {\n    cars.push(new Car());\n  }\n\n  const myNetwork = new NNetwork();\n  let worldPixels;\n  let canvas;\n  let image;\n\n  p.setup = () => {\n    canvas = p.createCanvas(WIDTH, HEIGHT);\n    p.noStroke();\n    p.background(255);\n    worldPixels = JSON.parse(window.localStorage.getItem('map'));\n    const image1 = p.get(0, 0, WIDTH, HEIGHT);\n    image1.loadPixels();\n\n    for (var i = 0; i < image1.pixels.length; i += 4) {\n      const startIndex = Math.floor(i / 4);\n      image1.pixels[i] = worldPixels[startIndex][0];\n      image1.pixels[i + 1] = worldPixels[startIndex][1];\n      image1.pixels[i + 2] = worldPixels[startIndex][2];\n      image1.pixels[i + 3] = 255;\n    }\n\n    image1.updatePixels();\n    image = image1;\n  };\n\n  p.mousePressed = () => {\n    console.log(p.get(p.mouseX, p.mouseY));\n  };\n\n  p.draw = () => {\n    p.update();\n\n    if (true) {\n      //frameCount++ % 30 === 0) {\n      p.background(255);\n\n      if (image) {\n        p.image(image, 0, 0, WIDTH, HEIGHT);\n      }\n\n      const car = cars[0];\n      p.rectMode(p.CENTER);\n      p.translate(car.x, car.y);\n      p.angleMode(p.DEGREES);\n      p.rotate(car.angle);\n      p.fill(150, 100, 200);\n      p.rect(0, 0, car.width, car.height);\n      p.fill(150, 150, 150);\n      p.rect(10, 0, 10, 15);\n      p.fill('black');\n      p.rect(25, -8.5, 4, 6);\n      p.rect(25, 8.5, 4, 6);\n      p.stroke('red');\n      car.sensors.map(sensor => {\n        const targetX = sensor.maxDistance * Math.cos(getRadian(car.angle));\n        const targetY = sensor.maxDistance * Math.sin(getRadian(car.angle));\n        p.rotate(-car.angle);\n        p.line(0, 0, targetX, targetY);\n        p.rect(sensor.foundX - car.x, sensor.foundY - car.y, 15, 15);\n      });\n      p.stroke(0);\n    }\n  };\n\n  p.update = () => {\n    /*\n    if (p.keyIsDown(87)) {\n      // UP\n      car.speedUp();\n    }\n    if (p.keyIsDown(83)) {\n      car.speedDown();\n    }\n    if (p.keyIsDown(65)) {\n      // LEFT\n      car.steerLeft();\n    }\n    if (p.keyIsDown(68)) {\n      car.steerRight();\n    }\n    */\n    cars.forEach(car => car.update(myNetwork, worldPixels));\n  };\n\n  p.myCustomRedrawAccordingToNewPropsHandler = newProps => {\n    if (canvas) //Make sure the canvas has been created\n      p.fill(newProps.color);\n  };\n\n  p.keyPressed = () => {\n    if (p.keyCode === 76) {}\n  };\n}","map":{"version":3,"sources":["/home/caner/Desktop/sa/selfcar/src/components/game-sketch.js"],"names":["Network","Layer","NNetwork","constructor","learningRate","inputLayer","hiddenLayer1","outputLayer","project","nn","input","hidden","output","WIDTH","HEIGHT","getRadian","angle","Math","PI","DistanceSensor","maxDistance","foundX","foundY","findIntersection","counter","worldPixels","carX","carY","targetX","targetY","carAngle","distance","sqrt","pow","pixel","floor","cos","sin","getValue","result","min","carCounter","Car","speedUp","speedDown","steerLeft","steerRight","update","myNetwork","x","speed","y","sensorData","collectSensorData","console","log","reset","output1","output2","activate","shouldSteerLeft","newSensorData","propagate","sensors","map","sensor","id","start","Date","now","width","height","maxSpeed","acc","sketch","p","frameCount","cars","i","push","canvas","image","setup","createCanvas","noStroke","background","JSON","parse","window","localStorage","getItem","image1","get","loadPixels","pixels","length","startIndex","updatePixels","mousePressed","mouseX","mouseY","draw","car","rectMode","CENTER","translate","angleMode","DEGREES","rotate","fill","rect","stroke","line","forEach","myCustomRedrawAccordingToNewPropsHandler","newProps","color","keyPressed","keyCode"],"mappings":"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","sourcesContent":["import {Network, Layer} from 'synaptic';\n\nclass NNetwork {\n  learningRate = 0.3;\n\n  constructor() {\n    var inputLayer = new Layer(2);\n    var hiddenLayer1 = new Layer(10);\n    // var hiddenLayer2 = new Layer(5);\n    var outputLayer = new Layer(2);\n    inputLayer.project(hiddenLayer1);\n    hiddenLayer1.project(outputLayer);\n    // hiddenLayer2.project(outputLayer);\n    this.nn = new Network({\n    \tinput: inputLayer,\n    \thidden: [hiddenLayer1],\n    \toutput: outputLayer\n    });\n\n    // console.log(this.nn)\n    // for (var i = 0; i < 10; i++) {\n    // \tthis.nn.activate([Math.random()]);\n    // \tthis.nn.propagate(\n    //     this.learningRate,\n    //     [Math.random(), Math.random(), Math.random(), Math.random()]\n    //   );\n    // }\n    // console.log('trained')\n    // console.log(this.nn.activate([Math.random()]));\n  }\n}\n\nconst WIDTH = 640;\nconst HEIGHT = 480;\n\nconst getRadian = angle => angle * Math.PI / 180\n\nclass DistanceSensor {\n  maxDistance = 100;\n  foundX = 0;\n  foundY = 0;\n\n  findIntersection = (counter, worldPixels, carX, carY, targetX, targetY, carAngle) => {\n    const distance = Math.sqrt(\n      Math.pow((carX - targetX), 2) +\n      Math.pow((carY - targetY), 2)\n    )\n    // console.log(distance)\n    if (counter > this.maxDistance) {\n      return false;\n    }\n    const pixel = worldPixels[Math.floor(carY) * WIDTH + Math.floor(carX)];\n    if (pixel && pixel[0] !== 0) {\n      // const centerX = carX + (targetX - carX ) / 2\n      // const centerY = carY + (targetY - carY ) / 2\n      return this.findIntersection(\n        counter + 1,\n        worldPixels,\n        carX + 1 * Math.cos(getRadian(carAngle)),\n        carY + 1 * Math.sin(getRadian(carAngle)),\n        targetX,\n        targetY,\n        carAngle\n      )\n    }\n    return [carX, carY]\n  }\n\n  getValue = (worldPixels, carX, carY, carAngle) => {\n    const targetX = carX + this.maxDistance * Math.cos(getRadian(carAngle)) + 20;\n    const targetY = carY + this.maxDistance * Math.sin(getRadian(carAngle)) + 12.5;\n    if (worldPixels) {\n      const result = this.findIntersection(0, worldPixels, carX, carY, targetX, targetY, carAngle);\n      const [foundX, foundY] = result ? result : [targetX, targetY]\n      this.foundX = foundX;\n      this.foundY = foundY;\n      return Math.min(1,\n        Math.sqrt(Math.pow((carX - foundX), 2) + Math.pow((carY - foundY), 2))\n        / this.maxDistance\n      );\n    }\n    return 0;\n  };\n}\n\nlet carCounter = 0;\n\nclass Car {\n  constructor() {\n    this.reset();\n    this.id = carCounter++;\n  }\n\n  reset() {\n    this.start = Date.now();\n    this.x = 80;\n    this.y = 100;\n    this.width = 40;\n    this.height = 25;\n    this.angle = 0;\n    this.sensors = [new DistanceSensor()];\n\n    this.speed = 2;\n    this.maxSpeed = 3;\n    this.acc = 0.5;\n  }\n\n  speedUp = () => {\n    // this.speed = Math.min(this.maxSpeed, this.speed += this.acc);\n  };\n\n  speedDown = () => {\n    // this.speed = Math.max(0.1, this.speed -= this.acc);\n  };\n\n  steerLeft = () => {\n    this.angle = (this.angle - 4) % 360;\n  }\n\n  steerRight = () => {\n    this.angle = (this.angle + 4) % 360;\n  }\n\n  update = (myNetwork, worldPixels) => {\n    this.x += this.speed * Math.cos(getRadian(this.angle));\n    this.y += this.speed * Math.sin(getRadian(this.angle));\n\n    const sensorData = this.collectSensorData(worldPixels);\n    \n    if (sensorData[0] === 0) {\n      console.log('dead')\n      this.reset();\n    \t// myNetwork.nn.propagate(0.3, [((Date.now() - this.start) / 1000) / 20]);\n    } else {\n    \t// myNetwork.nn.propagate(0.3, [1]);\n    }\n\n\n    // TODO angle?\n    let [output1, output2] = myNetwork.nn.activate([\n      sensorData, this.angle\n    ]);\n\n    // if (this.speed === 0.1) {\n    //   console.log(this.id);\n    //   myNetwork.nn.propagate(0.1, [\n    //     Math.random(),\n    //     0.6\n    //   ])\n    // }\n\n    const shouldSteerLeft = output1 > output2\n    if (shouldSteerLeft) {\n      this.steerLeft();\n    } else {\n      this.steerRight();\n    }\n\n    // if (speed <= 0.5) {\n    //   this.speedDown();\n    // } else if (speed > 0.5) {\n    //   this.speedUp();\n    // }\n\n    const newSensorData = this.collectSensorData(worldPixels);\n    if (newSensorData[0] === 1) {\n      myNetwork.nn.propagate(0.3, [\n        0.5,\n        0.5\n      ])\n    } else if (newSensorData[0] < sensorData[0]){\n      myNetwork.nn.propagate(0.2,\n        shouldSteerLeft ? [0, 1] : [1, 0])\n    } else {\n      // myNetwork.nn.propagate(0.2, [output1, output2])\n    }\n  };\n\n  collectSensorData = (worldPixels) => {\n    return this.sensors.map(sensor =>\n      sensor.getValue(worldPixels, this.x, this.y, this.angle));\n  }\n};\n\nexport default function sketch(p){\n    let frameCount = 0;\n    const cars = [];\n    for (var i = 0; i < 100; i++) {\n      cars.push(new Car())\n    }\n    const myNetwork = new NNetwork();\n    let worldPixels;\n    let canvas;\n    let image;\n\n    p.setup = () => {\n      canvas = p.createCanvas(WIDTH, HEIGHT);\n      p.noStroke();\n      p.background(255);\n\n      worldPixels = JSON.parse(window.localStorage.getItem('map'));\n      const image1 = p.get(0, 0, WIDTH, HEIGHT);\n      image1.loadPixels();\n      for (var i = 0; i < image1.pixels.length; i += 4) {\n        const startIndex = Math.floor(i / 4);\n        image1.pixels[i] = worldPixels[startIndex][0];\n        image1.pixels[i + 1] = worldPixels[startIndex][1];\n        image1.pixels[i + 2] = worldPixels[startIndex][2];\n        image1.pixels[i + 3] = 255;\n      }\n      image1.updatePixels();\n      image = image1;\n    }\n\n    p.mousePressed = () => {\n      console.log(p.get(p.mouseX, p.mouseY));\n    }\n\n    p.draw = () => {\n      p.update();\n\n      if (true ) { //frameCount++ % 30 === 0) {\n\n        p.background(255);\n        if (image) {\n          p.image(image, 0, 0, WIDTH, HEIGHT);\n        }\n\n        const car = cars[0];\n        p.rectMode(p.CENTER)\n        p.translate(car.x, car.y);\n        p.angleMode(p.DEGREES);\n        p.rotate(car.angle);\n        p.fill(150, 100, 200);\n        p.rect(0, 0, car.width, car.height);\n        p.fill(150, 150, 150);\n        p.rect(10, 0, 10, 15);\n        p.fill('black');\n        p.rect(25, -8.5, 4, 6);\n        p.rect(25, 8.5, 4, 6);\n\n        p.stroke('red');\n        car.sensors.map(sensor => {\n          const targetX = sensor.maxDistance * Math.cos(getRadian(car.angle));\n          const targetY = sensor.maxDistance * Math.sin(getRadian(car.angle));\n          p.rotate(-car.angle);\n          p.line(0, 0, targetX, targetY)\n          p.rect(sensor.foundX - car.x, sensor.foundY - car.y, 15, 15);\n        });\n        p.stroke(0);\n      }\n    }\n\n    p.update = () => {\n      /*\n      if (p.keyIsDown(87)) {\n        // UP\n        car.speedUp();\n      }\n      if (p.keyIsDown(83)) {\n        car.speedDown();\n      }\n      if (p.keyIsDown(65)) {\n        // LEFT\n        car.steerLeft();\n      }\n      if (p.keyIsDown(68)) {\n        car.steerRight();\n      }\n      */\n\n      cars.forEach(car =>\n        car.update(myNetwork, worldPixels)\n      );\n    };\n\n    p.myCustomRedrawAccordingToNewPropsHandler = (newProps) => {\n      if(canvas) //Make sure the canvas has been created\n        p.fill(newProps.color);\n    }\n\n    p.keyPressed = () => {\n      if (p.keyCode === 76) {\n\n      }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}